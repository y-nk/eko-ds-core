'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var ts = require('typescript');
var util = require('util');

class TspmError extends Error {
    constructor(message) {
        super(message);
        this.name = 'TspmError';
    }
}

const regex = /(.+) \(([0-9]+):([0-9]+)\)/;
class ParseError extends TspmError {
    constructor({ file, data, error, range, regex: re }) {
        const buffer = range || 5;
        let { message } = error;
        let line = 0;
        let column = 0;
        let before = '<';
        let target = 'unknown';
        let after = '>';
        const matches = (re || regex).exec(message);
        if (matches) {
            message = matches[1];
            line = parseInt(matches[2], 10);
            column = parseInt(matches[3], 10);
            if (!(isNaN(line) || isNaN(column))) {
                const slice = data.split(/\r?\n/)[line - 1];
                before = slice.substring(column - buffer, column);
                target = slice.charAt(column);
                after = slice.substring(column + 1, column + 1 + buffer);
            }
        }
        super(`${message} (${file.destination}:${line}:${column}): '${before}⇝${target}⇜${after}'`);
        this.file = file;
        this.data = data;
        this.error = message;
        this.line = line;
        this.column = column;
        this.before = before;
        this.target = target;
        this.after = after;
    }
}

function isExportNamedDeclaration(data) {
    return data !== null &&
        data !== undefined &&
        (data.type === 'ExportAllDeclaration'
            || (data.type === 'ExportNamedDeclaration' && data.source !== null));
}

function isImportDeclaration(data) {
    return data !== null && data !== undefined && data.type === 'ImportDeclaration';
}

function isIdentifier(data) {
    return data !== null && data !== undefined && data.type === 'Identifier';
}

function isSimpleCallExpression(data) {
    return data !== null && data !== undefined && data.type === 'CallExpression';
}

function isIdentifier$1(data) {
    return data !== null && data !== undefined && data.type === 'Literal';
}

function isRequireCallExpression(data) {
    return data !== null &&
        data !== undefined &&
        isSimpleCallExpression(data) &&
        isIdentifier(data.callee) &&
        data.callee.name === 'require' &&
        data.arguments.length === 1 &&
        isIdentifier$1(data.arguments[0]);
}

class ResolutionError extends TspmError {
    constructor({ path: path$$1, module, declaration }) {
        super(`Failed to resolve '${path$$1}' in '${module}'`);
        this.path = path$$1;
        this.module = module;
        this.declaration = declaration;
    }
}

function isBuiltinModule(module) {
    const builtin = [
        'assert',
        'async_hooks',
        'buffer',
        'child_process',
        'cluster',
        'console',
        'constants',
        'crypto',
        'dgram',
        'dns',
        'domain',
        'events',
        'fs',
        'http',
        'http2',
        'https',
        'inspector',
        'module',
        'net',
        'os',
        'path',
        'perf_hooks',
        'process',
        'punycode',
        'querystring',
        'readline',
        'repl',
        'stream',
        'string_decoder',
        'timers',
        'tls',
        'tty',
        'url',
        'util',
        'v8',
        'vm',
        'zlib',
    ];
    return builtin.indexOf(module) !== -1;
}
class Declaration {
    constructor({ file, declaration, path: path$$1 }) {
        this.processed = false;
        this.declaration = declaration;
        this.file = file;
        this.original = path$$1;
    }
    get isMapped() {
        return Promise.resolve(this.processed);
    }
    get module() {
        return this.file.destination;
    }
    toString() {
        return `${this.module}: ${this.path}`;
    }
    async map(options) {
        if (this.processed) {
            return true;
        }
        const { resolvedModule: resolved } = ts.nodeModuleNameResolver(this.path, this.file.source.toString(), options, {
            fileExists: fs.existsSync,
            readFile: (f) => fs.readFileSync(f, 'utf8'),
        });
        this.processed = true;
        if (isBuiltinModule(this.path)) {
            return false;
        }
        else if (!resolved) {
            throw new ResolutionError({ declaration: this, module: this.file.source, path: this.path });
        }
        const { resolvedFileName: pathWithExtension, extension, isExternalLibraryImport: external } = resolved;
        const path$$1 = path.join(path.dirname(pathWithExtension), path.basename(pathWithExtension, extension));
        let resolution = path.relative(this.file.source.parent.toString(), path$$1);
        if (!resolution.startsWith('.')) {
            resolution = `./${resolution}`;
        }
        if (!external && (this.path !== resolution)) {
            this.update(resolution);
            return true;
        }
        return false;
    }
}

var __rest = (global && global.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
function getLiteral(declaration, file) {
    const literal = isExportNamedDeclaration(declaration) ? declaration.source :
        isImportDeclaration(declaration) ? declaration.source :
            isRequireCallExpression(declaration) ? declaration.arguments[0] :
                undefined;
    if (literal === undefined) {
        throw new TypeError(`Failed to find ES declaration in '${file.source}'`);
    }
    else if (!isIdentifier$1(literal)) {
        const type = literal ? literal.type : 'unknown';
        throw new TypeError(`Invalid ES declaration source type '${type}' in '${file.source}'`);
    }
    return literal;
}
class Declaration$1 extends Declaration {
    constructor(_a) {
        var { declaration, file } = _a, rest = __rest(_a, ["declaration", "file"]);
        const literal = getLiteral(declaration, file);
        if (typeof literal.value !== 'string') {
            throw new TypeError(`The type '${typeof literal.value}' of the ES source must be 'string' for '${file.source}'`);
        }
        super(Object.assign({ declaration, file }, rest, { path: literal.value }));
    }
    get literal() {
        return getLiteral(this.declaration, this.file);
    }
    get path() {
        return this.literal.value;
    }
    update(value) {
        if (this.literal.raw) {
            this.literal.raw = this.literal.raw.replace(this.path, value);
        }
        this.literal.value = value;
    }
}

class Export extends Declaration$1 {
    constructor(options) {
        const { type } = options.declaration;
        if (type === 'ExportNamedDeclaration' && options.declaration.source === null) {
            throw new TypeError(`Cannot create an ES export with a 'null' literal`);
        }
        super(options);
    }
}

class Import extends Declaration$1 {
}

let acorn;
let escodegen;
let estraverse;
const plugins = {};
try {
    acorn = require('acorn-jsx');
    escodegen = require('escodegen-wallaby');
    estraverse = require('estraverse-fb');
    plugins.jsx = true;
}
catch ({ message }) {
    if (process.env.EF_TSPM_SHOW_JSX_LOADING_WARNING) {
        process.stderr.write(`${message}\n`);
    }
    acorn = require('acorn');
    escodegen = require('escodegen');
    estraverse = require('estraverse');
}
const parse = acorn.parse;
const generate = escodegen.generate;
const attachComments = estraverse.attachComments;
const traverse = estraverse.traverse;

class Require extends Declaration$1 {
}

class ResolutionError$1 extends TspmError {
    constructor({ path: path$$1 }) {
        super(`File not found: '${path$$1}'`);
        this.path = path$$1;
    }
}

class Path {
    constructor(path$$1) {
        this.absolute = path.resolve(path$$1);
    }
    get path() {
        return this.absolute;
    }
    get name() {
        return path.basename(this.absolute);
    }
    get directory() {
        return new Path(path.dirname(this.absolute));
    }
    get parent() {
        return this.directory;
    }
    get extension() {
        return path.extname(this.absolute);
    }
    set extension(value) {
        if (!value.startsWith('.')) {
            throw Error(`Extension must start with a '.': ${value}`);
        }
        this.absolute = path.join(this.directory.toString(), `${path.basename(this.absolute, this.extension)}${value}`);
    }
    relative(base) {
        return path.relative((base || process.cwd).toString(), this.absolute);
    }
    join(path$$1) {
        return new Path(path.join(this.absolute, path$$1));
    }
    toString() {
        return this.absolute;
    }
}

var __asyncValues = (global && global.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (global && global.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
var __asyncGenerator = (global && global.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
function commonPathPrefix(paths) {
    const { done, value: left } = paths.next();
    if (done) {
        return '';
    }
    let index = left.length;
    for (const right of paths) {
        for (let i = 0; i < index; ++i) {
            if (left.charAt(i) !== right.charAt(i)) {
                index = i;
                break;
            }
        }
    }
    return left.substring(0, index);
}
class File {
    constructor({ path: path$$1, options, config: { fileNames }, extension }) {
        this.source = new Path(path$$1.toString());
        this.root = new Path(commonPathPrefix(fileNames[Symbol.iterator]()));
        this.options = options;
        this.extension = extension;
        if (!fs.existsSync(this.destination.toString())) {
            throw new ResolutionError$1({ path: this.destination });
        }
    }
    get isMapped() {
        return (async () => {
            var e_1, _a, e_2, _b;
            let mapped = false;
            try {
                for (var _c = __asyncValues(this.imports()), _d; _d = await _c.next(), !_d.done;) {
                    const imprt = _d.value;
                    mapped = mapped || await imprt.isMapped;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _e = __asyncValues(this.exports()), _f; _f = await _e.next(), !_f.done;) {
                    const imprt = _f.value;
                    mapped = mapped || await imprt.isMapped;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) await _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return mapped;
        })();
    }
    get destination() {
        const { outDir } = this.options;
        if (!outDir) {
            throw new TypeError(`Only 'outDir' is supported`);
        }
        const out = new Path(outDir);
        const destination = out.join(this.source.relative(this.root));
        destination.extension = this.extension;
        return destination;
    }
    map(options) {
        return __asyncGenerator(this, arguments, function* map_1() {
            var e_3, _a, e_4, _b;
            try {
                for (var _c = __asyncValues(this.imports()), _d; _d = yield __await(_c.next()), !_d.done;) {
                    const imprt = _d.value;
                    const mapped = yield __await(imprt.map(options));
                    if (mapped) {
                        yield yield __await(imprt);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) yield __await(_a.call(_c));
                }
                finally { if (e_3) throw e_3.error; }
            }
            try {
                for (var _e = __asyncValues(this.exports()), _f; _f = yield __await(_e.next()), !_f.done;) {
                    const exprt = _f.value;
                    const mapped = yield __await(exprt.map(options));
                    if (mapped) {
                        yield yield __await(exprt);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    toString() {
        return this.destination.toString();
    }
}

var __rest$1 = (global && global.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __await$1 = (global && global.__await) || function (v) { return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v); };
var __asyncValues$1 = (global && global.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncDelegator = (global && global.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$1(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator$1 = (global && global.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
class File$1 extends File {
    constructor(_a) {
        var options = __rest$1(_a, []);
        super(Object.assign({}, options, { extension: '.js' }));
        this.program = undefined;
    }
    get ast() {
        if (this.program) {
            return Promise.resolve(this.program);
        }
        else {
            return (async () => {
                const data = await readFile(this.destination.toString(), 'utf-8');
                try {
                    const comments = [];
                    const tokens = [];
                    const program = parse(data, {
                        allowHashBang: true,
                        ranges: true,
                        onComment: comments,
                        onToken: tokens,
                        sourceType: this.options.module === ts.ModuleKind.ES2015 ? 'module' : 'script',
                        ecmaVersion: 8,
                        plugins,
                    });
                    attachComments(program, comments, tokens);
                    return this.program = program;
                }
                catch (error) {
                    if (error instanceof SyntaxError) {
                        throw new ParseError({ file: this, error, data });
                    }
                    else {
                        throw error;
                    }
                }
            })();
        }
    }
    imports() {
        return __asyncGenerator$1(this, arguments, function* imports_1() {
            const ast = yield __await$1(this.ast);
            yield __await$1(yield* __asyncDelegator(__asyncValues$1(ast.body
                .filter(isImportDeclaration)
                .map(declaration => new Import({ file: this, declaration })))));
            const requires = [];
            traverse(ast, {
                enter: (declaration) => {
                    if (isRequireCallExpression(declaration)) {
                        requires.push(new Require({ file: this, declaration }));
                    }
                },
            });
            yield __await$1(yield* __asyncDelegator(__asyncValues$1(requires)));
        });
    }
    exports() {
        return __asyncGenerator$1(this, arguments, function* exports_1() {
            const { body } = yield __await$1(this.ast);
            yield __await$1(yield* __asyncDelegator(__asyncValues$1(body
                .filter(isExportNamedDeclaration)
                .map(declaration => new Export({ file: this, declaration })))));
        });
    }
    async write(path$$1, options) {
        const ast = await this.ast;
        const data = generate(ast, { comment: true });
        return writeFile((path$$1 === undefined) ? this.destination.toString() : path$$1, data, options);
    }
}

var __rest$2 = (global && global.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
class Declaration$2 extends Declaration {
    constructor(_a) {
        var { declaration, file } = _a, rest = __rest$2(_a, ["declaration", "file"]);
        if (!declaration.moduleSpecifier) {
            throw new TypeError(`No TS module specifier in '${file.source}'`);
        }
        const { kind, text } = declaration.moduleSpecifier;
        if (kind !== ts.SyntaxKind.StringLiteral) {
            throw new TypeError(`Invalid TS declaration literal kind '${kind}' in '${file.source}'`);
        }
        super(Object.assign({ declaration, file }, rest, { path: text }));
    }
    get literal() {
        return this.declaration.moduleSpecifier;
    }
    get path() {
        return this.literal.text;
    }
    update(value) {
        this.literal.text = value;
    }
}

class Export$1 extends Declaration$2 {
}

class Import$1 extends Declaration$2 {
}

var __rest$3 = (global && global.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __await$2 = (global && global.__await) || function (v) { return this instanceof __await$2 ? (this.v = v, this) : new __await$2(v); };
var __asyncValues$2 = (global && global.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncDelegator$1 = (global && global.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$2(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator$2 = (global && global.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await$2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
const readFile$1 = util.promisify(fs.readFile);
const writeFile$1 = util.promisify(fs.writeFile);
class File$2 extends File {
    constructor(_a) {
        var options = __rest$3(_a, []);
        super(Object.assign({}, options, { extension: '.d.ts' }));
        this.sourceFile = undefined;
    }
    get ast() {
        if (this.sourceFile) {
            return Promise.resolve(this.sourceFile);
        }
        else {
            return (async () => {
                const data = await readFile$1(this.destination.toString(), 'utf-8');
                try {
                    return this.sourceFile = ts.createSourceFile(this.destination.toString(), data, ts.ScriptTarget.Latest);
                }
                catch (error) {
                    if (error instanceof SyntaxError) {
                        throw new ParseError({ file: this, error, data });
                    }
                    else {
                        throw error;
                    }
                }
            })();
        }
    }
    imports() {
        return __asyncGenerator$2(this, arguments, function* imports_1() {
            const { statements } = yield __await$2(this.ast);
            yield __await$2(yield* __asyncDelegator$1(__asyncValues$2(statements
                .filter(({ kind }) => kind === ts.SyntaxKind.ImportDeclaration)
                .map(n => new Import$1({ file: this, declaration: n })))));
        });
    }
    exports() {
        return __asyncGenerator$2(this, arguments, function* exports_1() {
            const { statements } = yield __await$2(this.ast);
            yield __await$2(yield* __asyncDelegator$1(__asyncValues$2(statements
                .filter(({ kind }) => kind === ts.SyntaxKind.ExportDeclaration)
                .filter(n => n.moduleSpecifier)
                .map(n => new Export$1({ file: this, declaration: n })))));
        });
    }
    async write(path$$1, options) {
        const sourceFile = await this.ast;
        const { newLine } = this.options;
        const printer = ts.createPrinter({ newLine });
        const data = printer.printNode(ts.EmitHint.SourceFile, sourceFile, sourceFile);
        return writeFile$1((path$$1 === undefined) ? this.destination.toString() : path$$1, data, options);
    }
}

var __asyncValues$3 = (global && global.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await$3 = (global && global.__await) || function (v) { return this instanceof __await$3 ? (this.v = v, this) : new __await$3(v); };
var __asyncDelegator$2 = (global && global.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$3(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator$3 = (global && global.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await$3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
class Mapper {
    constructor({ tsconfig, projectRoot }) {
        const config = ts.readConfigFile(tsconfig, path$$1 => fs.readFileSync(path$$1, 'utf-8'));
        if (config.error) {
            throw new TypeError(ts.formatDiagnostics([config.error], {
                getCanonicalFileName: f => f,
                getCurrentDirectory: process.cwd,
                getNewLine: () => '\n',
            }));
        }
        const host = {
            fileExists: fs.existsSync,
            readDirectory: ts.sys.readDirectory,
            readFile: f => fs.readFileSync(f, 'utf8'),
            useCaseSensitiveFileNames: true,
        };
        const root = path.resolve(projectRoot || path.dirname(tsconfig));
        const parsed = ts.parseJsonConfigFileContent(config.config, host, root, { noEmit: true });
        const errors = parsed.errors.filter(d => d.category === ts.DiagnosticCategory.Error && d.code !== 18003);
        if (errors.length !== 0) {
            throw new TypeError(ts.formatDiagnostics(errors, {
                getCanonicalFileName: f => f,
                getCurrentDirectory: process.cwd,
                getNewLine: () => '\n',
            }));
        }
        parsed.options.rootDir = parsed.options.rootDir || projectRoot;
        this.parsed = parsed;
    }
    files() {
        return __asyncGenerator$3(this, arguments, function* files_1() {
            const config = this.parsed;
            const { options, fileNames } = config;
            const files = fileNames.filter(n => !n.endsWith('.d.ts'));
            yield __await$3(yield* __asyncDelegator$2(__asyncValues$3(files.map(path$$1 => new File$1({ path: path$$1, options, config })))));
            if (options.declaration) {
                yield __await$3(yield* __asyncDelegator$2(__asyncValues$3(files.map(path$$1 => new File$2({ path: path$$1, options, config })))));
            }
        });
    }
    map() {
        return __asyncGenerator$3(this, arguments, function* map_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues$3(this.files()), _c; _c = yield __await$3(_b.next()), !_c.done;) {
                    const file = _c.value;
                    yield __await$3(yield* __asyncDelegator$2(__asyncValues$3(file.map(this.parsed.options))));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await$3(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
}

var __rest$4 = (global && global.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __asyncValues$4 = (global && global.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await$4 = (global && global.__await) || function (v) { return this instanceof __await$4 ? (this.v = v, this) : new __await$4(v); };
var __asyncDelegator$3 = (global && global.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$4(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator$4 = (global && global.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await$4 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
function convert(_a) {
    var other = __rest$4(_a, []);
    return __asyncGenerator$4(this, arguments, function* convert_1() {
        const mapper = new Mapper(Object.assign({}, other));
        yield __await$4(yield* __asyncDelegator$3(__asyncValues$4(mapper.map())));
    });
}

exports.default = convert;
//# sourceMappingURL=index.cjs.js.map
