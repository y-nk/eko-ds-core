var __asyncValues = this && this.__asyncValues || function (o) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator](), i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
import * as fs from 'fs';
import * as process from 'process';
import * as yargs from 'yargs';
import convert from './convert';
import TspmError from './Error';
import ParseError from './error/Parse';
const colourful = {
    red: '\x1B[31m',
    yellow: '\x1B[33m',
    green: '\x1B[32m',
    blue: '\x1B[34m',
    black: '\x1B[30m',
    reset: '\x1B[0m'
};
const colourLess = Object.keys(colourful).reduce((o, k) => {
    o[k] = '';
    return o;
}, {});
const packageJson = JSON.parse(fs.readFileSync(`${ __dirname }/../../package.json`, 'utf-8'));
const {bugs} = packageJson;
export async function parseArguments(args) {
    const parser = yargs.usage('Usage: ef-tspm').option('verbose', {
        alias: 'v',
        default: false,
        description: 'Logs more information to the console'
    }).option('silent', {
        alias: 's',
        default: false,
        description: 'Logs no information but errors to the console'
    }).option('tsconfig', {
        alias: 'c',
        default: `${ process.cwd() }/tsconfig.json`,
        description: 'Determines the TypeScript configuration to read'
    }).option('projectRoot', {
        alias: 'r',
        default: process.cwd(),
        description: 'The location of the TypeScript project root'
    }).option('colour', {
        choices: [
            'yes',
            'auto',
            'no'
        ],
        default: 'auto',
        description: 'Enables colour in the console output'
    }).example('$0 -c ./tsconfig.json', 'Performs mapping of the files specified in the TypeScript configuration').epilogue('Performs mapping of the TypeScript module lookups to the correct paths. The executable uses the ' + 'TypeScript configuration to determine the input and output files. It then parses the output files and ' + 'updates any path mapping to the correct relative path');
    const {tsconfig, projectRoot, silent, verbose, colour} = parser.parse(args.slice());
    const options = {
        tsconfig,
        projectRoot,
        colour: colour === 'yes' ? true : colour === 'no' ? false : colour,
        verbose,
        silent
    };
    return options;
}
function colours(colour, stream) {
    return colour === true || colour === 'auto' && stream.isTTY ? colourful : colourLess;
}
export async function map(options) {
    var e_1, _a;
    const {
        projectRoot: root,
        colour,
        silent,
        verbose
    } = options;
    try {
        const {
            blue: r,
            yellow: p,
            green: t,
            reset: _
        } = colours(colour, process.stderr);
        const files = new Set();
        try {
            for (var _b = __asyncValues(convert(options)), _c; _c = await _b.next(), !_c.done;) {
                const mapped = _c.value;
                if (!silent && verbose) {
                    const {original, path, module} = mapped;
                    const relative = module.relative(root);
                    process.stdout.write(`${ t }Mapped${ _ } '${ r }${ relative }${ _ }': '${ p }${ original }${ _ }' â†’ '${ p }${ path }${ _ }'\n`);
                }
                files.add(mapped.file);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    await _a.call(_b);
            } finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        for (const file of files) {
            await file.write();
            if (!silent) {
                const relative = file.destination.relative(root);
                process.stdout.write(`${ t }Wrote${ _ } '${ r }${ relative }${ _ }'\n`);
            }
        }
        return 0;
    } catch (error) {
        const {
            red: r,
            yellow: y,
            blue: b,
            green: g,
            reset: _
        } = colours(colour, process.stderr);
        if (error instanceof ParseError) {
            const {
                error: msg,
                file: {destination: path},
                before: pre,
                target: token,
                after: post,
                column,
                line
            } = error;
            const formatted = `${ r }JavaScript parsing error${ _ }: ` + `${ y }${ msg }${ _ } (${ g }${ path }${ _ }:${ y }${ line }${ _ }:${ y }${ column }${ _ }): '${ pre }${ y }${ token }${ _ }${ post }'`;
            process.stderr.write(`${ formatted }\n`);
            return 3;
        } else if (error instanceof TspmError) {
            process.stderr.write(`${ error.message }\n`);
            return 2;
        }
        let {stack} = error;
        stack = stack.replace(/ \((.+):([0-9]+):([0-9]+)\)/g, ` (${ g }$1${ _ }:${ y }$2${ _ }:${ y }$3${ _ })`);
        stack = stack.replace(/^([^:]+?):([^()]+)/g, `${ r }$1${ _ }:${ y }$2${ _ }`);
        stack = stack.replace(/(at +)(.+)( +\()/g, `$1${ b }$2${ _ }$3`);
        stack = stack.replace(/(at +)(.+):([0-9]+):([0-9]+)/g, `$1${ g }$1${ _ }:${ y }$2${ _ }:${ y }$3${ _ }`);
        stack = stack.replace(/\(<anonymous>\)/g, `(${ g }<anonymous>${ _ })`);
        process.stderr.write(`${ stack }

${ r }Fatal Error Encountered${ _ }: ${ y }Please report this to '${ _ }${ bugs }${ y }'${ _ }
`);
        return 5;
    }
}
export default async function main(args) {
    return map(await parseArguments(args));
}    //# sourceMappingURL=main.js.map
