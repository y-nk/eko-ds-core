var __asyncValues = this && this.__asyncValues || function (o) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator](), i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = this && this.__await || function (v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i;
    function verb(n) {
        if (g[n])
            i[n] = function (v) {
                return new Promise(function (a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume('next', value);
    }
    function reject(value) {
        resume('throw', value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
    }
};
import { existsSync as fileExistsSync } from 'fs';
import FileNotFoundError from './error/FileNotFound';
import Path from './Path';
function commonPathPrefix(paths) {
    const {
        done,
        value: left
    } = paths.next();
    if (done) {
        return '';
    }
    let index = left.length;
    for (const right of paths) {
        for (let i = 0; i < index; ++i) {
            if (left.charAt(i) !== right.charAt(i)) {
                index = i;
                break;
            }
        }
    }
    return left.substring(0, index);
}
export default class File {
    constructor({
        path,
        options,
        config: {fileNames},
        extension
    }) {
        this.source = new Path(path.toString());
        this.root = new Path(commonPathPrefix(fileNames[Symbol.iterator]()));
        this.options = options;
        this.extension = extension;
        if (!fileExistsSync(this.destination.toString())) {
            throw new FileNotFoundError({ path: this.destination });
        }
    }
    get isMapped() {
        return (async () => {
            var e_1, _a, e_2, _b;
            let mapped = false;
            try {
                for (var _c = __asyncValues(this.imports()), _d; _d = await _c.next(), !_d.done;) {
                    const imprt = _d.value;
                    mapped = mapped || (await imprt.isMapped);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        await _a.call(_c);
                } finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            try {
                for (var _e = __asyncValues(this.exports()), _f; _f = await _e.next(), !_f.done;) {
                    const imprt = _f.value;
                    mapped = mapped || (await imprt.isMapped);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return))
                        await _b.call(_e);
                } finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
            return mapped;
        })();
    }
    get destination() {
        const {outDir} = this.options;
        if (!outDir) {
            throw new TypeError(`Only 'outDir' is supported`);
        }
        const out = new Path(outDir);
        const destination = out.join(this.source.relative(this.root));
        destination.extension = this.extension;
        return destination;
    }
    map(options) {
        return __asyncGenerator(this, arguments, function* map_1() {
            var e_3, _a, e_4, _b;
            try {
                for (var _c = __asyncValues(this.imports()), _d; _d = yield __await(_c.next()), !_d.done;) {
                    const imprt = _d.value;
                    const mapped = yield __await(imprt.map(options));
                    if (mapped) {
                        yield yield __await(imprt);
                    }
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        yield __await(_a.call(_c));
                } finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            try {
                for (var _e = __asyncValues(this.exports()), _f; _f = yield __await(_e.next()), !_f.done;) {
                    const exprt = _f.value;
                    const mapped = yield __await(exprt.map(options));
                    if (mapped) {
                        yield yield __await(exprt);
                    }
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return))
                        yield __await(_b.call(_e));
                } finally {
                    if (e_4)
                        throw e_4.error;
                }
            }
        });
    }
    toString() {
        return this.destination.toString();
    }
}    //# sourceMappingURL=File.js.map
