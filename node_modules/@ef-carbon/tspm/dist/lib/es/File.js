var __rest = this && this.__rest || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
            if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
    return t;
};
var __await = this && this.__await || function (v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncValues = this && this.__asyncValues || function (o) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator](), i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __asyncDelegator = this && this.__asyncDelegator || function (o) {
    var i, p;
    return i = {}, verb('next'), verb('throw', function (e) {
        throw e;
    }), verb('return'), i[Symbol.iterator] = function () {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function (v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === 'return'
            } : f ? f(v) : v;
        } : f;
    }
};
var __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i;
    function verb(n) {
        if (g[n])
            i[n] = function (v) {
                return new Promise(function (a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume('next', value);
    }
    function reject(value) {
        resume('throw', value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
    }
};
import {
    readFile as readFileSync,
    writeFile as writeFileSync
} from 'fs';
import { ModuleKind } from 'typescript';
import { promisify } from 'util';
import ParseError from '../error/Parse';
import Export from './Export';
import Import from './Import';
import isExportNamedDeclaration from './isExportNamedDeclaration';
import isImportDeclaration from './isImportDeclaration';
import isRequireCallExpression from './isRequireCallExpression';
import {
    attachComments,
    generate,
    parse,
    plugins,
    traverse
} from './parser';
import Require from './Require';
import Base from '../File';
const readFile = promisify(readFileSync);
const writeFile = promisify(writeFileSync);
export default class File extends Base {
    constructor(_a) {
        var options = __rest(_a, []);
        super(Object.assign({}, options, { extension: '.js' }));
        this.program = undefined;
    }
    get ast() {
        if (this.program) {
            return Promise.resolve(this.program);
        } else {
            return (async () => {
                const data = await readFile(this.destination.toString(), 'utf-8');
                try {
                    const comments = [];
                    const tokens = [];
                    const program = parse(data, {
                        allowHashBang: true,
                        ranges: true,
                        onComment: comments,
                        onToken: tokens,
                        sourceType: this.options.module === ModuleKind.ES2015 ? 'module' : 'script',
                        ecmaVersion: 8,
                        plugins
                    });
                    attachComments(program, comments, tokens);
                    return this.program = program;
                } catch (error) {
                    if (error instanceof SyntaxError) {
                        throw new ParseError({
                            file: this,
                            error,
                            data
                        });
                    } else {
                        throw error;
                    }
                }
            })();
        }
    }
    imports() {
        return __asyncGenerator(this, arguments, function* imports_1() {
            const ast = yield __await(this.ast);
            yield __await(yield* __asyncDelegator(__asyncValues(ast.body.filter(isImportDeclaration).map(declaration => new Import({
                file: this,
                declaration
            })))));
            const requires = [];
            traverse(ast, {
                enter: declaration => {
                    if (isRequireCallExpression(declaration)) {
                        requires.push(new Require({
                            file: this,
                            declaration
                        }));
                    }
                }
            });
            yield __await(yield* __asyncDelegator(__asyncValues(requires)));
        });
    }
    exports() {
        return __asyncGenerator(this, arguments, function* exports_1() {
            const {body} = yield __await(this.ast);
            yield __await(yield* __asyncDelegator(__asyncValues(body.filter(isExportNamedDeclaration).map(declaration => new Export({
                file: this,
                declaration
            })))));
        });
    }
    async write(path, options) {
        const ast = await this.ast;
        const data = generate(ast, { comment: true });
        return writeFile(path === undefined ? this.destination.toString() : path, data, options);
    }
}    //# sourceMappingURL=File.js.map
