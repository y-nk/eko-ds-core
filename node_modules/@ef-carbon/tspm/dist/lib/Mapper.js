var __asyncValues = this && this.__asyncValues || function (o) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator](), i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = this && this.__await || function (v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncDelegator = this && this.__asyncDelegator || function (o) {
    var i, p;
    return i = {}, verb('next'), verb('throw', function (e) {
        throw e;
    }), verb('return'), i[Symbol.iterator] = function () {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function (v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === 'return'
            } : f ? f(v) : v;
        } : f;
    }
};
var __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
        throw new TypeError('Symbol.asyncIterator is not defined.');
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
        return this;
    }, i;
    function verb(n) {
        if (g[n])
            i[n] = function (v) {
                return new Promise(function (a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume('next', value);
    }
    function reject(value) {
        resume('throw', value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
    }
};
import {
    existsSync as fileExistsSync,
    readFileSync as fileReadSync
} from 'fs';
import {
    dirname,
    resolve
} from 'path';
import * as ts from 'typescript';
import EsFile from './es/File';
import TsFile from './ts/File';
export default class Mapper {
    constructor({tsconfig, projectRoot}) {
        const config = ts.readConfigFile(tsconfig, path => fileReadSync(path, 'utf-8'));
        if (config.error) {
            throw new TypeError(ts.formatDiagnostics([config.error], {
                getCanonicalFileName: f => f,
                getCurrentDirectory: process.cwd,
                getNewLine: () => '\n'
            }));
        }
        const host = {
            fileExists: fileExistsSync,
            readDirectory: ts.sys.readDirectory,
            readFile: f => fileReadSync(f, 'utf8'),
            useCaseSensitiveFileNames: true
        };
        const root = resolve(projectRoot || dirname(tsconfig));
        const parsed = ts.parseJsonConfigFileContent(config.config, host, root, { noEmit: true });
        const errors = parsed.errors.filter(d => d.category === ts.DiagnosticCategory.Error && d.code !== 18003);
        if (errors.length !== 0) {
            throw new TypeError(ts.formatDiagnostics(errors, {
                getCanonicalFileName: f => f,
                getCurrentDirectory: process.cwd,
                getNewLine: () => '\n'
            }));
        }
        parsed.options.rootDir = parsed.options.rootDir || projectRoot;
        this.parsed = parsed;
    }
    files() {
        return __asyncGenerator(this, arguments, function* files_1() {
            const config = this.parsed;
            const {options, fileNames} = config;
            const files = fileNames.filter(n => !n.endsWith('.d.ts'));
            yield __await(yield* __asyncDelegator(__asyncValues(files.map(path => new EsFile({
                path,
                options,
                config
            })))));
            if (options.declaration) {
                yield __await(yield* __asyncDelegator(__asyncValues(files.map(path => new TsFile({
                    path,
                    options,
                    config
                })))));
            }
        });
    }
    map() {
        return __asyncGenerator(this, arguments, function* map_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.files()), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const file = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(file.map(this.parsed.options))));
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        yield __await(_a.call(_b));
                } finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        });
    }
}    //# sourceMappingURL=Mapper.js.map
